---
description: React Native and Expo Best Practices
globs: ['src/**/*.tsx', 'src/**/*.ts']
alwaysApply: false
---

# Modern React Native & Expo Development Standards

## Core Architecture Principles

- Use functional components with TypeScript interfaces
- Prefer composition over inheritance
- Follow React best practices and hooks patterns
- Use Expo Router for file-based navigation
- Implement proper error boundaries
- Use strict TypeScript mode for type safety

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exported component, subcomponents, helpers, static content, types
- Use the "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals; use concise syntax
- Use declarative JSX patterns

## TypeScript Best Practices

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects or maps instead
- Use functional components with TypeScript interfaces
- Implement strict null checks and proper error handling
- Define proper prop types and return types
- Use generic types for reusable components
- Leverage discriminated unions for complex state scenarios

## React Import Patterns

- **Never import React default**: JSX is available at runtime, no need for `import React from 'react'`
- **Import specific APIs**: Use `import { useState, useEffect } from 'react'` for hooks
- **Import React Native components**: Use `import { View, Text } from 'react-native'`
- **Import third-party APIs directly**: Import only what you need from each package
- **No default React import**: Modern React Native handles JSX transformation automatically

## Performance Optimization

- Minimize useState and useEffect; prefer context and reducers for state management
- Use React.memo() for expensive components
- Implement useMemo and useCallback hooks appropriately
- Avoid unnecessary re-renders with proper dependency arrays
- Use FlatList for long lists with proper optimization props
- Implement code splitting with React.lazy and Suspense
- Optimize images: use WebP format, include size data, implement lazy loading
- Use Expo's AppLoading and SplashScreen for optimized startup

## Safe Area Management

- Use SafeAreaProvider from react-native-safe-area-context globally
- Wrap top-level components with SafeAreaView for proper insets
- Use SafeAreaScrollView for scrollable content
- Avoid hardcoding padding/margins; use SafeAreaView and context hooks
- Handle notches, status bars, and screen insets properly on both platforms

## Navigation Best Practices

- Use Expo Router for file-based routing and navigation
- Implement proper deep linking and universal links
- Use typed navigation with proper route parameters
- Handle navigation state properly in components
- Implement proper back button handling
- Use navigation guards for protected routes

## State Management

- Use React Context and useReducer for global state
- Leverage TanStack Query for data fetching and caching
- Implement proper error states and loading states
- Use Zustand for complex state management when needed
- Handle optimistic updates appropriately
- Implement proper cache invalidation strategies

## Error Handling and Validation

- Use Zod for runtime validation and error handling
- Implement proper error logging with Sentry
- Handle errors at the beginning of functions
- Use early returns for error conditions
- Avoid deeply nested if statements
- Implement global error boundaries
- Provide user-friendly error messages
- Log errors with proper context

## Testing Standards

- Write unit tests using Jest and React Native Testing Library
- Implement integration tests for critical user flows
- Use snapshot testing for UI consistency
- Test accessibility features and screen readers
- Mock external dependencies properly
- Test error scenarios and edge cases
- Maintain high test coverage for critical paths

## Security Guidelines

- Sanitize user inputs to prevent XSS attacks
- Use react-native-encrypted-storage for sensitive data
- Ensure secure communication with HTTPS
- Implement proper authentication flows
- Validate all API responses
- Use environment variables for sensitive configuration
- Follow Expo's security guidelines

## Accessibility (a11y) Standards

- Use proper accessibility labels and hints
- Implement screen reader support
- Ensure proper focus management
- Use semantic elements appropriately
- Test with accessibility tools
- Support dynamic text sizing
- Implement proper color contrast
- Handle accessibility announcements

## Platform-Specific Considerations

- Test extensively on both iOS and Android
- Handle platform differences gracefully
- Use Platform.select() for platform-specific code
- Implement proper keyboard handling
- Handle different screen sizes and orientations
- Consider platform-specific UI patterns
- Test on different device types and OS versions

## Development Workflow

- Use Expo's managed workflow for streamlined development
- Implement proper environment configuration
- Use expo-constants for environment variables
- Handle device permissions gracefully
- Implement OTA updates with expo-updates
- Follow Expo's deployment best practices
- Use proper version management and release channels

## Code Organization

- Use feature-based folder structure
- Keep components focused and single-purpose
- Extract custom hooks for reusable logic
- Organize utilities and helpers appropriately
- Use barrel exports for clean imports
- Follow consistent naming conventions
- Implement proper file and folder naming patterns
