# React Native Performance Optimization Guide

Comprehensive performance guidelines for building fast, responsive React Native and Expo applications with optimal user experience.

## Core Performance Principles

- **60fps Target**: Maintain smooth animations and interactions at 60 frames per second
- **Fast Startup**: Minimize app launch time and time to interactive
- **Memory Efficiency**: Prevent memory leaks and optimize memory usage
- **Bundle Size**: Keep JavaScript bundle size minimal for faster loading
- **Battery Efficiency**: Minimize CPU usage and battery drain
- **Network Optimization**: Reduce network requests and optimize data loading

## Rendering Performance

### Component Optimization

#### React.memo for Expensive Components
- Memoize components that receive complex props
- Implement custom comparison functions for complex objects
- Use shallow comparison for simple props
- Avoid memoizing every component - focus on expensive ones

#### useMemo for Expensive Calculations
- Memoize expensive filtering and sorting operations
- Cache expensive data transformations
- Use appropriate dependency arrays
- Avoid over-memoization of cheap calculations

#### useCallback for Event Handlers
- Memoize event handlers to prevent child re-renders
- Use stable references for callback functions
- Include proper dependencies in dependency array
- Focus on callbacks passed to memoized components

### List Performance

#### FlatList Optimization
- Use proper keyExtractor for stable keys
- Implement getItemLayout for fixed-height items
- Configure removeClippedSubviews for memory optimization
- Set appropriate batch rendering parameters
- Use initialNumToRender and windowSize appropriately
- Disable virtualization only when necessary

#### Large List Virtualization
- Use VirtualizedList for complex data structures
- Implement proper getItem and getItemCount functions
- Configure batch parameters for optimal performance
- Handle dynamic item heights carefully

## State Management Performance

### Avoid Excessive State Updates
- Batch related state updates together
- Use single state object instead of multiple useState calls
- Minimize the number of re-renders
- Use functional state updates when appropriate

### useReducer for Complex State
- Use useReducer for complex state logic
- Implement proper action types with TypeScript
- Handle state updates immutably
- Use discriminated unions for action types

## Image and Asset Optimization

### Image Performance
- Use Expo Image for better performance and caching
- Implement proper image caching policies
- Set appropriate image priorities
- Use placeholders while loading
- Handle image errors gracefully
- Preload critical images

### Asset Optimization Strategies
- Use appropriate image formats (WebP, PNG, SVG)
- Implement responsive images for different screen sizes
- Compress images appropriately
- Use vector graphics for icons when possible

## Memory Management

### Prevent Memory Leaks
- Clean up timers and intervals in useEffect cleanup
- Unsubscribe from event listeners and subscriptions
- Use useRef for mutable values that don't cause re-renders
- Handle component unmounting properly

### Efficient Data Structures
- Use Maps for frequent key-based lookups
- Use Sets for unique collections
- Avoid creating objects during render
- Memoize expensive object creations

## Animation Performance

### React Native Reanimated Optimization
- Use useAnimatedStyle for UI thread animations
- Leverage shared values for smooth animations
- Use runOnJS sparingly for JavaScript thread operations
- Implement proper animation cleanup

### Gesture Handler Optimization
- Use Gesture API for complex gesture handling
- Implement gestures on UI thread when possible
- Handle gesture state changes efficiently
- Use appropriate gesture configurations

## Network Performance

### Efficient Data Fetching
- Implement proper caching strategies with TanStack Query
- Use appropriate stale times and cache times
- Implement retry logic with exponential backoff
- Prefetch data when appropriate

### Request Optimization
- Batch multiple requests when possible
- Implement request deduplication
- Use proper request timeouts
- Handle network errors gracefully

## Bundle Size Optimization

### Code Splitting
- Lazy load non-critical screens and components
- Use React.lazy and Suspense for dynamic imports
- Split code by routes and features
- Implement proper loading states

### Tree Shaking Optimization
- Import only specific functions from libraries
- Avoid importing entire libraries when possible
- Use ES modules for better tree shaking
- Analyze bundle size regularly

## Performance Monitoring

### Performance Metrics
- Measure component render times in development
- Track user interaction response times
- Monitor memory usage patterns
- Use performance profiling tools

### Memory Usage Monitoring
- Monitor JavaScript heap size in development
- Track memory leaks and growth patterns
- Log memory warnings appropriately
- Implement memory usage alerts

## Platform-Specific Optimizations

### iOS Performance
- Enable hardware acceleration when appropriate
- Optimize for high refresh rate displays
- Handle iOS-specific performance characteristics
- Test on various iOS device types

### Android Performance
- Enable hardware acceleration for Android
- Optimize draw operations and reduce overdraw
- Handle Android-specific memory management
- Test across different Android devices and OS versions

This comprehensive performance guide ensures your React Native and Expo applications deliver exceptional user experiences with optimal speed, responsiveness, and efficiency across all platforms.